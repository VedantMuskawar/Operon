# Atomic Order Creation with Zone Updates

## Problem Statement

When creating an order, users can:
1. **Add a new region** (city + region combination) in Section 2
2. **Update unit prices** for products in an existing zone

**Current Issue:**
- Zone creation/updates happen immediately when user interacts with UI
- Order creation happens separately when "Create Order" is clicked
- **Problem:** If order creation fails after zone is created/updated, we have inconsistent state
- **Risk:** Zone exists but no order references it, or prices updated but order uses old prices

**Requirement:**
- When submitting Create Order, if new region/price changes exist:
  1. First write to `DELIVERY_ZONES` collection
  2. Then use the new/updated `zoneId` to create Order document
- **Must be atomic:** Both operations succeed or both fail (no partial state)

---

## Current Flow Analysis

### Current Implementation

**Section 2 (DeliveryZoneSelectionSection):**
- User can add new region via `_showAddRegionDialog`
- Calls `cubit.createRegion()` → immediately saves to Firestore
- User can update prices via `_showRegionPriceDialog`
- Calls `cubit.updateZonePrice()` → immediately saves to Firestore

**Order Creation (OrderSummarySection):**
- On "Create Order" button click:
  - Calls `cubit.createOrder()` with current `state.selectedZoneId`
  - Creates order document in `PENDING_ORDERS`

**Problem:**
- Zone changes are saved **before** order creation
- If order creation fails, zone changes remain (orphaned)
- No rollback mechanism

---

## Solution Options

### Option 1: Firestore Transaction (Recommended)

**Approach:**
Use Firestore batch write to ensure atomicity of both operations.

**Implementation:**
```dart
Future<String> createOrderWithZoneUpdates({
  // Order data
  required String clientId,
  required String clientName,
  required String clientPhone,
  // ... other order fields
  
  // Zone updates (if any)
  DeliveryZone? newZone,                    // New region to create
  Map<String, double>? updatedPrices,        // Product prices to update
  String? existingZoneId,                   // Existing zone ID (if no new zone)
}) async {
  final batch = _firestore.batch();
  String finalZoneId;
  
  // Step 1: Create/Update Zone if needed
  if (newZone != null) {
    // Create new zone
    final zoneRef = _ordersRef(_organizationId)
        .collection('DELIVERY_ZONES')
        .doc(); // Auto-generated ID
    finalZoneId = zoneRef.id;
    
    batch.set(zoneRef, {
      'city': newZone.city,
      'region': newZone.region,
      'isActive': true,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
    });
    
    // Add prices for new zone
    if (updatedPrices != null) {
      for (final entry in updatedPrices.entries) {
        final priceRef = zoneRef
            .collection('PRICES')
            .doc(entry.key); // productId
        batch.set(priceRef, {
          'productId': entry.key,
          'productName': _getProductName(entry.key),
          'unitPrice': entry.value,
          'deliverable': true,
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
    }
  } else if (updatedPrices != null && existingZoneId != null) {
    // Update prices in existing zone
    finalZoneId = existingZoneId;
    final zoneRef = _ordersRef(_organizationId)
        .collection('DELIVERY_ZONES')
        .doc(existingZoneId);
    
    for (final entry in updatedPrices.entries) {
      final priceRef = zoneRef
          .collection('PRICES')
          .doc(entry.key);
      batch.set(priceRef, {
        'productId': entry.key,
        'productName': _getProductName(entry.key),
        'unitPrice': entry.value,
        'deliverable': true,
        'updatedAt': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));
    }
  } else {
    // No zone changes, use existing zone
    finalZoneId = existingZoneId ?? throw Exception('Zone ID required');
  }
  
  // Step 2: Create Order document
  final orderRef = _ordersRef(_organizationId)
      .collection('PENDING_ORDERS')
      .doc();
  
  batch.set(orderRef, {
    'orderId': orderRef.id,
    'orderNumber': '', // Will be generated by Cloud Function
    'clientId': clientId,
    'clientName': clientName,
    'clientPhone': clientPhone,
    'items': items.map((item) => item.toJson()).toList(),
    'deliveryZone': {
      'zoneId': finalZoneId,
      'city': newZone?.city ?? _getZoneCity(finalZoneId),
      'region': newZone?.region ?? _getZoneRegion(finalZoneId),
    },
    'pricing': pricing.toJson(),
    'includeGstInTotal': includeGstInTotal,
    'paymentType': paymentType,
    'priority': priority,
    'status': 'pending',
    'organizationId': _organizationId,
    'createdBy': createdBy,
    'createdAt': FieldValue.serverTimestamp(),
    'updatedAt': FieldValue.serverTimestamp(),
    // ... other fields
  });
  
  // Step 3: Commit transaction
  await batch.commit();
  
  return orderRef.id;
}
```

**Pros:**
- ✅ Atomic: All operations succeed or all fail
- ✅ No orphaned zones
- ✅ No race conditions
- ✅ Built-in Firestore feature (reliable)
- ✅ Can be implemented in mobile app (no Cloud Function needed)

**Cons:**
- ⚠️ Batch writes have 500 document limit (should be fine for our use case)
- ⚠️ Requires tracking pending zone changes in state

**State Management:**
```dart
class CreateOrderState {
  // ... existing fields ...
  
  // Track pending zone changes
  DeliveryZone? pendingNewZone;              // New zone to create
  Map<String, double>? pendingPriceUpdates;  // Prices to update
  bool hasPendingZoneChanges;                // Flag to check if changes exist
}
```

---

### Option 2: Cloud Function (Server-Side Atomic Operation)

**Approach:**
Create a Cloud Function that handles both zone creation/update and order creation atomically.

**Implementation:**
```typescript
// Cloud Function: createOrderWithZone
exports.createOrderWithZone = functions.https.onCall(async (data, context) => {
  // Verify authentication
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }
  
  const { orgId, orderData, zoneUpdates } = data;
  
  const db = admin.firestore();
  const batch = db.batch();
  
  let finalZoneId;
  
  // Step 1: Handle zone updates
  if (zoneUpdates?.newZone) {
    // Create new zone
    const zoneRef = db
      .collection('ORGANIZATIONS')
      .doc(orgId)
      .collection('DELIVERY_ZONES')
      .doc();
    
    finalZoneId = zoneRef.id;
    
    batch.set(zoneRef, {
      city: zoneUpdates.newZone.city,
      region: zoneUpdates.newZone.region,
      isActive: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
    
    // Add prices
    if (zoneUpdates.prices) {
      for (const [productId, unitPrice] of Object.entries(zoneUpdates.prices)) {
        const priceRef = zoneRef.collection('PRICES').doc(productId);
        batch.set(priceRef, {
          productId,
          unitPrice,
          deliverable: true,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      }
    }
  } else if (zoneUpdates?.priceUpdates && zoneUpdates?.zoneId) {
    // Update existing zone prices
    finalZoneId = zoneUpdates.zoneId;
    const zoneRef = db
      .collection('ORGANIZATIONS')
      .doc(orgId)
      .collection('DELIVERY_ZONES')
      .doc(zoneUpdates.zoneId);
    
    for (const [productId, unitPrice] of Object.entries(zoneUpdates.priceUpdates)) {
      const priceRef = zoneRef.collection('PRICES').doc(productId);
      batch.set(priceRef, {
        productId,
        unitPrice,
        deliverable: true,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    }
  } else {
    finalZoneId = orderData.deliveryZone.zoneId;
  }
  
  // Step 2: Create order
  const orderRef = db
    .collection('ORGANIZATIONS')
    .doc(orgId)
    .collection('PENDING_ORDERS')
    .doc();
  
  batch.set(orderRef, {
    ...orderData,
    orderId: orderRef.id,
    deliveryZone: {
      ...orderData.deliveryZone,
      zoneId: finalZoneId,
    },
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });
  
  // Step 3: Commit
  await batch.commit();
  
  return { orderId: orderRef.id, zoneId: finalZoneId };
});
```

**Mobile App Call:**
```dart
Future<String> createOrderWithZoneUpdates({
  required Map<String, dynamic> orderData,
  DeliveryZone? newZone,
  Map<String, double>? priceUpdates,
  String? existingZoneId,
}) async {
  final callable = FirebaseFunctions.instance.httpsCallable('createOrderWithZone');
  
  final result = await callable.call({
    'orgId': _organizationId,
    'orderData': orderData,
    'zoneUpdates': {
      if (newZone != null) 'newZone': {
        'city': newZone.city,
        'region': newZone.region,
      },
      if (priceUpdates != null) 'prices': priceUpdates,
      if (existingZoneId != null) 'zoneId': existingZoneId,
    },
  });
  
  return result.data['orderId'] as String;
}
```

**Pros:**
- ✅ Atomic operation guaranteed
- ✅ Server-side validation possible
- ✅ Can add additional business logic
- ✅ Better security (server validates data)

**Cons:**
- ⚠️ Requires Cloud Function deployment
- ⚠️ Additional latency (network call)
- ⚠️ More complex error handling
- ⚠️ Requires Firebase Functions setup

---

### Option 3: Two-Phase with Rollback

**Approach:**
1. Save zone changes first
2. Create order
3. If order creation fails, rollback zone changes

**Implementation:**
```dart
Future<String> createOrderWithZoneUpdates({
  // ... parameters
}) async {
  String? createdZoneId;
  List<String> updatedPriceIds = [];
  
  try {
    // Phase 1: Create/Update Zone
    if (newZone != null) {
      createdZoneId = await _createZone(newZone, updatedPrices);
    } else if (updatedPrices != null) {
      await _updateZonePrices(existingZoneId!, updatedPrices);
      createdZoneId = existingZoneId;
    } else {
      createdZoneId = existingZoneId!;
    }
    
    // Phase 2: Create Order
    final orderId = await _createOrder(
      orderData: orderData,
      zoneId: createdZoneId,
    );
    
    return orderId;
  } catch (e) {
    // Rollback: Delete created zone if order creation failed
    if (createdZoneId != null && newZone != null) {
      await _deleteZone(createdZoneId);
    }
    // Note: Can't easily rollback price updates
    rethrow;
  }
}
```

**Pros:**
- ✅ Simpler than Cloud Function
- ✅ Can use existing repository methods

**Cons:**
- ❌ Not truly atomic (race conditions possible)
- ❌ Rollback of price updates is difficult
- ❌ If app crashes between phase 1 and 2, rollback won't happen
- ❌ Not recommended for production

---

## Recommended Solution: Option 1 (Firestore Transaction)

### Why Option 1?

1. **True Atomicity:** Firestore batch writes are atomic
2. **No Server Dependency:** Can be implemented entirely in mobile app
3. **Better Performance:** No network round-trip to Cloud Function
4. **Simpler Architecture:** Uses existing Firestore features
5. **Reliable:** Firestore handles retries and consistency

### Implementation Strategy

#### Step 1: Track Pending Zone Changes in State

```dart
class CreateOrderState {
  // ... existing fields ...
  
  // Zone change tracking
  DeliveryZone? pendingNewZone;              // New zone to create (not yet saved)
  Map<String, double>? pendingPriceUpdates;  // Price updates (not yet saved)
  String? pendingZoneCity;                   // City for pending zone
  String? pendingZoneRegion;                 // Region for pending zone
  bool get hasPendingZoneChanges => 
      pendingNewZone != null || 
      (pendingPriceUpdates != null && pendingPriceUpdates!.isNotEmpty);
}
```

#### Step 2: Modify Zone Creation/Update Methods

**Current:** Immediately save to Firestore
**New:** Store in state, save during order creation

```dart
// Instead of immediately saving:
void addPendingZone({
  required String city,
  required String region,
  Map<String, double>? prices,
}) {
  emit(state.copyWith(
    pendingNewZone: DeliveryZone(
      id: '', // Will be generated
      city: city,
      region: region,
      isActive: true,
    ),
    pendingPriceUpdates: prices,
    pendingZoneCity: city,
    pendingZoneRegion: region,
  ));
}

void addPendingPriceUpdates(Map<String, double> prices) {
  final updated = Map<String, double>.from(state.pendingPriceUpdates ?? {});
  updated.addAll(prices);
  emit(state.copyWith(pendingPriceUpdates: updated));
}
```

#### Step 3: Update Order Creation to Use Batch Write

```dart
Future<String> createOrder({
  // ... existing parameters
}) async {
  emit(state.copyWith(status: ViewStatus.loading));

  try {
    final batch = _firestore.batch();
    String finalZoneId;
    
    // Handle zone updates if any
    if (state.hasPendingZoneChanges) {
      if (state.pendingNewZone != null) {
        // Create new zone
        final zoneRef = _deliveryZonesRef(_organizationId).doc();
        finalZoneId = zoneRef.id;
        
        batch.set(zoneRef, {
          'city': state.pendingNewZone!.city,
          'region': state.pendingNewZone!.region,
          'isActive': true,
          'createdAt': FieldValue.serverTimestamp(),
          'updatedAt': FieldValue.serverTimestamp(),
        });
        
        // Add prices for new zone
        if (state.pendingPriceUpdates != null) {
          for (final entry in state.pendingPriceUpdates!.entries) {
            final priceRef = zoneRef
                .collection('PRICES')
                .doc(entry.key);
            batch.set(priceRef, {
              'productId': entry.key,
              'productName': _getProductName(entry.key),
              'unitPrice': entry.value,
              'deliverable': true,
              'updatedAt': FieldValue.serverTimestamp(),
            });
          }
        }
      } else if (state.pendingPriceUpdates != null && state.selectedZoneId != null) {
        // Update existing zone prices
        finalZoneId = state.selectedZoneId!;
        final zoneRef = _deliveryZonesRef(_organizationId).doc(finalZoneId);
        
        for (final entry in state.pendingPriceUpdates!.entries) {
          final priceRef = zoneRef
              .collection('PRICES')
              .doc(entry.key);
          batch.set(priceRef, {
            'productId': entry.key,
            'productName': _getProductName(entry.key),
            'unitPrice': entry.value,
            'deliverable': true,
            'updatedAt': FieldValue.serverTimestamp(),
          }, SetOptions(merge: true));
        }
      } else {
        finalZoneId = state.selectedZoneId ?? throw Exception('Zone ID required');
      }
    } else {
      // No pending changes, use existing zone
      finalZoneId = state.selectedZoneId ?? throw Exception('Zone ID required');
    }
    
    // Get zone details for order
    final zone = state.zones.firstWhere(
      (z) => z.id == finalZoneId,
      orElse: () => DeliveryZone(
        id: finalZoneId,
        city: state.pendingZoneCity ?? state.selectedCity ?? '',
        region: state.pendingZoneRegion ?? '',
        isActive: true,
      ),
    );
    
    // Create order document
    final orderRef = _pendingOrdersRef(_organizationId).doc();
    
    // Calculate pricing
    double totalSubtotal = 0;
    double totalGst = 0;
    for (final item in state.selectedItems) {
      totalSubtotal += item.subtotal;
      if (includeGstInTotal && item.hasGst) {
        totalGst += item.gstAmount;
      }
    }
    final totalAmount = totalSubtotal + totalGst;
    final remainingAmount = advanceAmount != null && advanceAmount > 0
        ? totalAmount - advanceAmount
        : null;
    
    batch.set(orderRef, {
      'orderId': orderRef.id,
      'orderNumber': '', // Generated by Cloud Function
      'clientId': clientId,
      'clientName': clientName,
      'clientPhone': clientPhone,
      'items': state.selectedItems.map((item) => item.toJson()).toList(),
      'deliveryZone': {
        'zoneId': finalZoneId,
        'city': zone.city,
        'region': zone.region,
      },
      'pricing': {
        'subtotal': totalSubtotal,
        'totalGst': totalGst,
        'totalAmount': totalAmount,
        'currency': 'INR',
      },
      'includeGstInTotal': includeGstInTotal,
      'paymentType': paymentType,
      'priority': priority,
      'status': 'pending',
      'organizationId': _organizationId,
      'createdBy': createdBy,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
      if (advanceAmount != null && advanceAmount > 0) 'advanceAmount': advanceAmount,
      if (advancePaymentAccountId != null) 'advancePaymentAccountId': advancePaymentAccountId,
      if (remainingAmount != null) 'remainingAmount': remainingAmount,
    });
    
    // Commit batch (atomic operation)
    await batch.commit();
    
    emit(state.copyWith(
      status: ViewStatus.success,
      // Clear pending changes after successful commit
      pendingNewZone: null,
      pendingPriceUpdates: null,
    ));
    
    return orderRef.id;
  } catch (e) {
    emit(
      state.copyWith(
        status: ViewStatus.failure,
        message: 'Failed to create order: ${e.toString()}',
      ),
    );
    rethrow;
  }
}
```

---

## UI/UX Considerations

### Option A: Save Zone Changes Immediately (Current)
- **Pros:** User sees changes immediately, can verify
- **Cons:** Risk of orphaned zones if order creation fails

### Option B: Save Zone Changes on Order Submit (Recommended)
- **Pros:** Atomic operation, no orphaned data
- **Cons:** User doesn't see zone in list until order is created

**Recommendation:** **Option B** with visual feedback:
- Show "Pending Zone" indicator in UI
- Display pending prices in summary
- Show message: "Zone will be created when order is submitted"

---

## Error Handling

### Scenario 1: Zone Creation Succeeds, Order Creation Fails
- **With Batch:** Both fail (atomic)
- **Without Batch:** Zone exists but no order (inconsistent state)

### Scenario 2: Network Failure During Commit
- Firestore automatically retries
- If all retries fail, entire batch fails (no partial state)

### Scenario 3: Concurrent Zone Creation
- Firestore handles concurrency with transactions
- Last write wins (acceptable for zone creation)

---

## Migration Strategy

### Phase 1: Add Pending State Tracking
- Add `pendingNewZone` and `pendingPriceUpdates` to state
- Modify UI to show "pending" indicators
- Don't save zones immediately

### Phase 2: Implement Batch Write
- Update `createOrder()` to use batch write
- Test atomicity with various scenarios

### Phase 3: Remove Immediate Zone Saves
- Remove `createRegion()` immediate save
- Remove `updateZonePrice()` immediate save
- All zone changes happen during order creation

---

## Summary

**Recommended Approach:** **Option 1 - Firestore Batch Write**

**Key Benefits:**
1. ✅ True atomicity (all or nothing)
2. ✅ No orphaned zones
3. ✅ No Cloud Function dependency
4. ✅ Better performance
5. ✅ Simpler architecture

**Implementation Steps:**
1. Track pending zone changes in `CreateOrderState`
2. Modify UI to show pending changes (don't save immediately)
3. Update `createOrder()` to use Firestore batch write
4. Commit zone creation/updates and order creation atomically

**Trade-offs:**
- Zone won't appear in list until order is created
- Need to handle "pending" state in UI
- Slightly more complex state management

This approach ensures data consistency and prevents orphaned zones while maintaining good user experience.

